c
current_vertex.value
current_vertex
possible_paths[current_vertex]
n
c
value
key
s
key.value
s
{ cost: new_cost, last_edge: edge }
n
 possible_paths.has_key?(next_vertex)
s
display new_cost
dispaly new_cost
display next_vertex.value
s
current_cost
s
display current_vertex.value
current_vertex.value
current_vertex
current_cost
n
c
n
s
display shortest_paths.size
display shortest_paths
display sortest_paths
display sortest_path
n
c
s
c
v.value
display 
v
data
c
n
c
vc
s
dijkstra2(v1)
output
quit
v2
v1
c
prc
prc.call(value2, value1)
s
self[v2]
self[v1]
v2
v1
c
prc
s
n
s
n
s
display @queue
display @map
dipslay @map
c
n
has_key?(key)
key
value
n
s
n
s
n
s
value
key
display @queue.store
display @queue.index_map
display @queue
display @map
c
n
s
ss
s
 has_key?(key)
key
c
queue.index_map
queue.index_amp
queue
queue.prc=
queue.prc
queue
 @queue.peek
@map
c
@map
c
quit
cquit
possible_paths.size
s
shortest_paths.size
shortest_paths
s
display next_vertex.value
possible_paths.size
s
display new_cost
next_vertex.value
s
current_cost
s
current_vertex.out_edges.size
current_vertex.out_edges
current_vertex.out_edge
current_vertex
s
display k.value
quit
c
v[:cost] < min_cost
c
 min_cost
 v[:cost]
 v[:cost] < min_cost
c
display min_vertex
c
get_vertex(possible_paths)
current_vertex
possible_paths[current_vertex]
c
display v
display v['cost']
