c
prc
s
n
s
n
s
display @queue
display @map
dipslay @map
c
n
has_key?(key)
key
value
n
s
n
s
n
s
value
key
display @queue.store
display @queue.index_map
display @queue
display @map
c
n
s
ss
s
 has_key?(key)
key
c
queue.index_map
queue.index_amp
queue
queue.prc=
queue.prc
queue
 @queue.peek
@map
c
@map
c
quit
cquit
possible_paths.size
s
shortest_paths.size
shortest_paths
s
display next_vertex.value
possible_paths.size
s
display new_cost
next_vertex.value
s
current_cost
s
current_vertex.out_edges.size
current_vertex.out_edges
current_vertex.out_edge
current_vertex
s
display k.value
quit
c
v[:cost] < min_cost
c
 min_cost
 v[:cost]
 v[:cost] < min_cost
c
display min_vertex
c
get_vertex(possible_paths)
current_vertex
possible_paths[current_vertex]
c
display v
display v['cost']
